# File Markers MVP (v0.1.0) Implementation Plan

## Overview

Implement the Minimum Viable Product for the File Markers VSCode extension. This includes adding/removing markers via context menu, visual markers in the Explorer panel using FileDecorationProvider, 6 default marker types, and file-based workspace storage.

## Current State Analysis

The project is a freshly scaffolded VSCode extension with:
- Standard Yo Code template structure
- Only `helloWorld` command implemented (`src/extension.ts:16-20`)
- Build system configured (esbuild, TypeScript, ESLint)
- No marker functionality exists

### Key Discoveries:

- `src/extension.ts:7-23` - Main activate function (template only)
- `package.json:14-21` - Only contains helloWorld command contribution
- VSCode engine version `^1.108.1` supports all required APIs
- Build outputs to `dist/extension.js` via esbuild

## Desired End State

After implementation:
1. Right-clicking files/folders in Explorer shows "File Markers" submenu with 6 marker options
2. Selecting a marker applies a visual badge and color to the item in Explorer
3. Marked items show "Remove Marker" option in context menu
4. Markers persist to `.vscode/file-markers.json` and survive VSCode restarts
5. Extension activates on startup (no explicit activation event needed)

### Verification:
- Press F5 to launch Extension Development Host
- Right-click any file → see "File Markers" submenu
- Select a marker → see badge appear next to filename
- Close and reopen VSCode → marker persists
- Check `.vscode/file-markers.json` contains the marker data

## What We're NOT Doing

- F3: Change Marker (v0.2.0)
- F6: Custom Marker Types (v0.2.0)
- F7: WorkspaceState storage option (v0.2.0)
- F8: Bulk Operations (v0.3.0)
- F9: Marker Inheritance (v1.0.0)
- F10: Quick Toggle Keyboard Shortcut (v0.3.0)
- F11: Status Bar Summary (v1.0.0)
- Settings/configuration UI
- Tests beyond basic smoke tests

## Implementation Approach

Build from the data layer up:
1. Define types and constants first
2. Build storage layer (can be tested independently)
3. Build decoration provider (depends on storage)
4. Add commands (depends on storage + decoration provider)
5. Wire everything in extension activation

---

## Phase 1: Core Types & Default Markers

### Overview

Define TypeScript interfaces and default marker types as constants. This establishes the data model used throughout the extension.

### Changes Required:

#### 1. Create Types File

**File**: `src/types.ts` (new file)

```typescript
import * as vscode from 'vscode';

/**
 * Defines a marker type that can be applied to files/folders
 */
export interface MarkerType {
  id: string;
  badge: string;
  color: vscode.ThemeColor;
  label: string;
  sortOrder: number;
}

/**
 * Storage format for persisted markers
 */
export interface MarkerStorageData {
  version: number;
  markers: Record<string, string>; // relativePath -> markerId
}

/**
 * Event fired when markers change
 */
export interface MarkerChangeEvent {
  uri: vscode.Uri;
  markerId: string | undefined;
}
```

#### 2. Create Default Markers Constants

**File**: `src/markers.ts` (new file)

```typescript
import * as vscode from 'vscode';
import { MarkerType } from './types';

/**
 * Default marker types shipped with the extension
 * Colors use VSCode theme colors for consistency
 */
export const DEFAULT_MARKERS: readonly MarkerType[] = [
  {
    id: 'done',
    badge: '✓',
    color: new vscode.ThemeColor('gitDecoration.addedResourceForeground'),
    label: 'Done',
    sortOrder: 1,
  },
  {
    id: 'in-progress',
    badge: '◐',
    color: new vscode.ThemeColor('gitDecoration.modifiedResourceForeground'),
    label: 'In Progress',
    sortOrder: 2,
  },
  {
    id: 'pending',
    badge: '○',
    color: new vscode.ThemeColor('gitDecoration.deletedResourceForeground'),
    label: 'Pending',
    sortOrder: 3,
  },
  {
    id: 'important',
    badge: '★',
    color: new vscode.ThemeColor('editorWarning.foreground'),
    label: 'Important',
    sortOrder: 4,
  },
  {
    id: 'review',
    badge: '◉',
    color: new vscode.ThemeColor('editorInfo.foreground'),
    label: 'Needs Review',
    sortOrder: 5,
  },
  {
    id: 'question',
    badge: '?',
    color: new vscode.ThemeColor('editorHint.foreground'),
    label: 'Question',
    sortOrder: 6,
  },
] as const;

/**
 * Get a marker type by ID
 */
export function getMarkerById(id: string): MarkerType | undefined {
  return DEFAULT_MARKERS.find(m => m.id === id);
}
```

### Success Criteria:

#### Automated Verification:

- [x] Type checking passes: `npm run check-types`
- [x] Linting passes: `npm run lint`
- [x] Files exist at correct paths

#### Manual Verification:

- [ ] Review types match PRD specification

**Implementation Note**: After completing this phase and all automated verification passes, proceed to Phase 2.

---

## Phase 2: MarkerStorage Service

### Overview

Implement the persistence layer that reads/writes markers to `.vscode/file-markers.json`. This service manages all marker state and notifies listeners when markers change.

### Changes Required:

#### 1. Create MarkerStorage Class

**File**: `src/storage.ts` (new file)

```typescript
import * as vscode from 'vscode';
import * as path from 'path';
import { MarkerStorageData, MarkerChangeEvent } from './types';

const STORAGE_VERSION = 1;
const STORAGE_FILENAME = 'file-markers.json';

export class MarkerStorage implements vscode.Disposable {
  private markers: Map<string, string> = new Map();
  private storageUri: vscode.Uri | undefined;
  private disposables: vscode.Disposable[] = [];
  private writeDebounceTimer: NodeJS.Timeout | undefined;

  private readonly _onDidChangeMarkers = new vscode.EventEmitter<MarkerChangeEvent>();
  readonly onDidChangeMarkers = this._onDidChangeMarkers.event;

  constructor() {
    // Watch for workspace folder changes
    this.disposables.push(
      vscode.workspace.onDidChangeWorkspaceFolders(() => this.initialize())
    );
  }

  async initialize(): Promise<void> {
    const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
    if (!workspaceFolder) {
      this.markers.clear();
      this.storageUri = undefined;
      return;
    }

    this.storageUri = vscode.Uri.joinPath(
      workspaceFolder.uri,
      '.vscode',
      STORAGE_FILENAME
    );

    await this.load();
  }

  private async load(): Promise<void> {
    if (!this.storageUri) {
      return;
    }

    try {
      const content = await vscode.workspace.fs.readFile(this.storageUri);
      const data: MarkerStorageData = JSON.parse(
        Buffer.from(content).toString('utf8')
      );

      if (data.version === STORAGE_VERSION && data.markers) {
        this.markers = new Map(Object.entries(data.markers));
      }
    } catch {
      // File doesn't exist or is invalid - start fresh
      this.markers.clear();
    }
  }

  private async save(): Promise<void> {
    if (!this.storageUri) {
      return;
    }

    const data: MarkerStorageData = {
      version: STORAGE_VERSION,
      markers: Object.fromEntries(this.markers),
    };

    const content = Buffer.from(JSON.stringify(data, null, 2), 'utf8');

    // Ensure .vscode directory exists
    const vscodeDir = vscode.Uri.joinPath(this.storageUri, '..');
    try {
      await vscode.workspace.fs.createDirectory(vscodeDir);
    } catch {
      // Directory may already exist
    }

    await vscode.workspace.fs.writeFile(this.storageUri, content);
  }

  private scheduleSave(): void {
    if (this.writeDebounceTimer) {
      clearTimeout(this.writeDebounceTimer);
    }
    this.writeDebounceTimer = setTimeout(() => {
      this.save().catch(err => {
        console.error('Failed to save markers:', err);
      });
    }, 100);
  }

  /**
   * Get the marker ID for a given URI
   */
  getMarker(uri: vscode.Uri): string | undefined {
    const relativePath = this.getRelativePath(uri);
    if (!relativePath) {
      return undefined;
    }
    return this.markers.get(relativePath);
  }

  /**
   * Set or update a marker for a given URI
   */
  setMarker(uri: vscode.Uri, markerId: string): void {
    const relativePath = this.getRelativePath(uri);
    if (!relativePath) {
      return;
    }

    this.markers.set(relativePath, markerId);
    this.scheduleSave();
    this._onDidChangeMarkers.fire({ uri, markerId });
  }

  /**
   * Remove a marker from a given URI
   */
  removeMarker(uri: vscode.Uri): void {
    const relativePath = this.getRelativePath(uri);
    if (!relativePath) {
      return;
    }

    if (this.markers.delete(relativePath)) {
      this.scheduleSave();
      this._onDidChangeMarkers.fire({ uri, markerId: undefined });
    }
  }

  /**
   * Check if a URI has a marker
   */
  hasMarker(uri: vscode.Uri): boolean {
    return this.getMarker(uri) !== undefined;
  }

  /**
   * Get all marked URIs (for refreshing decorations)
   */
  getAllMarkedUris(): vscode.Uri[] {
    const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
    if (!workspaceFolder) {
      return [];
    }

    return Array.from(this.markers.keys()).map(relativePath =>
      vscode.Uri.joinPath(workspaceFolder.uri, relativePath)
    );
  }

  private getRelativePath(uri: vscode.Uri): string | undefined {
    const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
    if (!workspaceFolder) {
      return undefined;
    }

    const workspacePath = workspaceFolder.uri.fsPath;
    const filePath = uri.fsPath;

    if (!filePath.startsWith(workspacePath)) {
      return undefined;
    }

    // Get relative path and normalize separators
    return path.relative(workspacePath, filePath).split(path.sep).join('/');
  }

  dispose(): void {
    if (this.writeDebounceTimer) {
      clearTimeout(this.writeDebounceTimer);
    }
    this._onDidChangeMarkers.dispose();
    this.disposables.forEach(d => d.dispose());
  }
}
```

### Success Criteria:

#### Automated Verification:

- [x] Type checking passes: `npm run check-types`
- [x] Linting passes: `npm run lint`

#### Manual Verification:

- [ ] Storage file format matches PRD specification

**Implementation Note**: After completing this phase and all automated verification passes, proceed to Phase 3.

---

## Phase 3: FileDecorationProvider

### Overview

Implement the visual layer that renders badges and colors on files/folders in the Explorer panel using VSCode's FileDecorationProvider API.

### Changes Required:

#### 1. Create FileDecorationProvider Class

**File**: `src/decorationProvider.ts` (new file)

```typescript
import * as vscode from 'vscode';
import { MarkerStorage } from './storage';
import { getMarkerById } from './markers';

export class MarkerDecorationProvider
  implements vscode.FileDecorationProvider, vscode.Disposable
{
  private disposables: vscode.Disposable[] = [];

  private readonly _onDidChangeFileDecorations =
    new vscode.EventEmitter<vscode.Uri | vscode.Uri[] | undefined>();
  readonly onDidChangeFileDecorations = this._onDidChangeFileDecorations.event;

  constructor(private readonly storage: MarkerStorage) {
    // Listen for marker changes and refresh decorations
    this.disposables.push(
      storage.onDidChangeMarkers(event => {
        this._onDidChangeFileDecorations.fire(event.uri);
      })
    );
  }

  provideFileDecoration(
    uri: vscode.Uri,
    _token: vscode.CancellationToken
  ): vscode.ProviderResult<vscode.FileDecoration> {
    const markerId = this.storage.getMarker(uri);
    if (!markerId) {
      return undefined;
    }

    const marker = getMarkerById(markerId);
    if (!marker) {
      return undefined;
    }

    return {
      badge: marker.badge,
      color: marker.color,
      tooltip: `File Marker: ${marker.label}`,
      propagate: false,
    };
  }

  /**
   * Refresh all decorations (e.g., after loading from storage)
   */
  refresh(): void {
    this._onDidChangeFileDecorations.fire(undefined);
  }

  dispose(): void {
    this._onDidChangeFileDecorations.dispose();
    this.disposables.forEach(d => d.dispose());
  }
}
```

### Success Criteria:

#### Automated Verification:

- [x] Type checking passes: `npm run check-types`
- [x] Linting passes: `npm run lint`

#### Manual Verification:

- [ ] Decorations render correctly in Explorer (tested in Phase 5)

**Implementation Note**: After completing this phase and all automated verification passes, proceed to Phase 4.

---

## Phase 4: Commands & Context Menu

### Overview

Register commands for adding/removing markers and configure the context menu contributions in package.json.

### Changes Required:

#### 1. Create Commands Module

**File**: `src/commands.ts` (new file)

```typescript
import * as vscode from 'vscode';
import { MarkerStorage } from './storage';
import { DEFAULT_MARKERS, getMarkerById } from './markers';

export function registerCommands(
  context: vscode.ExtensionContext,
  storage: MarkerStorage
): void {
  // Register individual "add marker" commands for each marker type
  for (const marker of DEFAULT_MARKERS) {
    const disposable = vscode.commands.registerCommand(
      `file-markers.addMarker.${marker.id}`,
      (uri: vscode.Uri) => {
        if (uri) {
          storage.setMarker(uri, marker.id);
        }
      }
    );
    context.subscriptions.push(disposable);
  }

  // Register "remove marker" command
  const removeDisposable = vscode.commands.registerCommand(
    'file-markers.removeMarker',
    (uri: vscode.Uri) => {
      if (uri) {
        storage.removeMarker(uri);
      }
    }
  );
  context.subscriptions.push(removeDisposable);

  // Register command to show current marker info (for testing/debugging)
  const infoDisposable = vscode.commands.registerCommand(
    'file-markers.showMarkerInfo',
    (uri: vscode.Uri) => {
      if (!uri) {
        return;
      }

      const markerId = storage.getMarker(uri);
      if (!markerId) {
        vscode.window.showInformationMessage('No marker on this file.');
        return;
      }

      const marker = getMarkerById(markerId);
      if (marker) {
        vscode.window.showInformationMessage(
          `Marker: ${marker.badge} ${marker.label}`
        );
      }
    }
  );
  context.subscriptions.push(infoDisposable);
}
```

#### 2. Update package.json

**File**: `package.json`
**Changes**: Replace the `contributes` section with commands and menus

```json
{
  "contributes": {
    "commands": [
      {
        "command": "file-markers.addMarker.done",
        "title": "✓ Done",
        "category": "File Markers"
      },
      {
        "command": "file-markers.addMarker.in-progress",
        "title": "◐ In Progress",
        "category": "File Markers"
      },
      {
        "command": "file-markers.addMarker.pending",
        "title": "○ Pending",
        "category": "File Markers"
      },
      {
        "command": "file-markers.addMarker.important",
        "title": "★ Important",
        "category": "File Markers"
      },
      {
        "command": "file-markers.addMarker.review",
        "title": "◉ Needs Review",
        "category": "File Markers"
      },
      {
        "command": "file-markers.addMarker.question",
        "title": "? Question",
        "category": "File Markers"
      },
      {
        "command": "file-markers.removeMarker",
        "title": "Remove Marker",
        "category": "File Markers"
      }
    ],
    "menus": {
      "explorer/context": [
        {
          "submenu": "file-markers.submenu",
          "group": "2_workspace",
          "when": "explorerResourceIsFolder || explorerResourceIsRoot || !explorerResourceIsFolder"
        }
      ],
      "file-markers.submenu": [
        {
          "command": "file-markers.addMarker.done",
          "group": "markers@1"
        },
        {
          "command": "file-markers.addMarker.in-progress",
          "group": "markers@2"
        },
        {
          "command": "file-markers.addMarker.pending",
          "group": "markers@3"
        },
        {
          "command": "file-markers.addMarker.important",
          "group": "markers@4"
        },
        {
          "command": "file-markers.addMarker.review",
          "group": "markers@5"
        },
        {
          "command": "file-markers.addMarker.question",
          "group": "markers@6"
        },
        {
          "command": "file-markers.removeMarker",
          "group": "remove@1"
        }
      ]
    },
    "submenus": [
      {
        "id": "file-markers.submenu",
        "label": "File Markers"
      }
    ]
  }
}
```

### Success Criteria:

#### Automated Verification:

- [x] Type checking passes: `npm run check-types`
- [x] Linting passes: `npm run lint`
- [x] Extension compiles: `npm run compile`

#### Manual Verification:

- [ ] Context menu structure matches PRD specification

**Implementation Note**: After completing this phase and all automated verification passes, proceed to Phase 5.

---

## Phase 5: Integration & Polish

### Overview

Wire everything together in the extension's activate function, register the FileDecorationProvider, and ensure proper cleanup on deactivation.

### Changes Required:

#### 1. Update Extension Entry Point

**File**: `src/extension.ts`
**Changes**: Replace entire contents

```typescript
import * as vscode from 'vscode';
import { MarkerStorage } from './storage';
import { MarkerDecorationProvider } from './decorationProvider';
import { registerCommands } from './commands';

let storage: MarkerStorage | undefined;
let decorationProvider: MarkerDecorationProvider | undefined;

export async function activate(
  context: vscode.ExtensionContext
): Promise<void> {
  console.log('File Markers extension is now active');

  // Initialize storage
  storage = new MarkerStorage();
  await storage.initialize();
  context.subscriptions.push(storage);

  // Initialize decoration provider
  decorationProvider = new MarkerDecorationProvider(storage);
  context.subscriptions.push(decorationProvider);

  // Register decoration provider with VSCode
  context.subscriptions.push(
    vscode.window.registerFileDecorationProvider(decorationProvider)
  );

  // Register commands
  registerCommands(context, storage);

  // Refresh decorations after initialization
  decorationProvider.refresh();
}

export function deactivate(): void {
  storage = undefined;
  decorationProvider = undefined;
}
```

#### 2. Update package.json Activation Events (if needed)

**File**: `package.json`
**Changes**: Ensure activation events array is empty (activates on startup)

The current `"activationEvents": []` is correct - VSCode will activate the extension on startup since we have command contributions.

### Success Criteria:

#### Automated Verification:

- [x] Type checking passes: `npm run check-types`
- [x] Linting passes: `npm run lint`
- [x] Extension compiles: `npm run compile`
- [ ] Extension packages without errors: `npx vsce package --skip-license` (if vsce installed)

#### Manual Verification:

- [x] Press F5 to launch Extension Development Host
- [x] Right-click a file in Explorer → "File Markers" submenu appears
- [x] Select "✓ Done" → badge appears next to file
- [x] Right-click same file → "Remove Marker" visible
- [x] Click "Remove Marker" → badge disappears
- [x] Add marker to file, close VSCode, reopen → marker persists
- [x] Check `.vscode/file-markers.json` exists with correct format
- [x] Test on folder → marker appears on folder
- [x] Test multiple markers on different files

**Implementation Note**: After completing this phase and all verification passes, the MVP is complete.

---

## Testing Strategy

### Unit Tests (Future - not in MVP scope):

- MarkerStorage: load/save/get/set/remove operations
- MarkerDecorationProvider: decoration generation
- Commands: proper marker application

### Integration Tests (Future):

- End-to-end marker workflow
- Persistence across sessions
- Multi-root workspace handling

### Manual Testing Steps (MVP):

1. Launch Extension Development Host (F5)
2. Create a new folder and open it in VSCode
3. Create several test files
4. Right-click file → File Markers → select each marker type
5. Verify badges appear with correct symbols
6. Verify colors are applied
7. Test "Remove Marker" functionality
8. Close and reopen VSCode → verify persistence
9. Check `.vscode/file-markers.json` format
10. Test on folders

## Performance Considerations

- **Debounced writes**: Storage saves are debounced (100ms) to prevent rapid writes
- **Efficient lookups**: Markers stored in Map for O(1) access
- **Lazy loading**: Markers loaded only when extension activates
- **Minimal decorations**: FileDecorationProvider returns quickly for non-marked files

## Migration Notes

N/A - This is the initial implementation. No migration needed.

## File Structure After Implementation

```
src/
├── extension.ts      # Entry point, wires components together
├── types.ts          # TypeScript interfaces
├── markers.ts        # Default marker definitions
├── storage.ts        # MarkerStorage class (persistence)
├── decorationProvider.ts  # FileDecorationProvider
├── commands.ts       # Command registrations
└── test/
    └── extension.test.ts  # Tests (to be expanded)
```

## References

- Research document: `thoughts/shared/research/2026-01-31-project-initialization-state.md`
- PRD: `PRD.md`
- VSCode FileDecorationProvider API: https://code.visualstudio.com/api/references/vscode-api#FileDecorationProvider
