# File Markers v0.2.0 Implementation Plan

## Overview

Implement v0.2.0 features: Configurable marker types stored in the markers file itself, simplified flat context menu, and QuickPick-based marker selection. This release focuses on extensibility while simplifying the UX.

## Current State Analysis

The MVP v0.1.0 is complete with:
- 6 hardcoded default markers in `src/markers.ts:8-51`
- File-based storage at `.vscode/file-markers.json` with only marker assignments
- Nested submenu context menu with all 6 markers listed
- No configuration support

### Key Files:

- `src/markers.ts:8-51` - Hardcoded `DEFAULT_MARKERS` array
- `src/markers.ts:56-58` - `getMarkerById()` only searches defaults
- `src/storage.ts:41-58` - Loads only `markers` object from storage
- `src/commands.ts:10-20` - Registers commands for each `DEFAULT_MARKERS` entry
- `package.json:17-97` - Static submenu with 6 marker commands

## Desired End State

After implementation:
1. Marker types defined in `.vscode/file-markers.json` alongside marker assignments
2. Default markers shipped as initial file content (users can modify/add/remove)
3. Flat context menu: "File Markers: Add Marker..." and "File Markers: Remove Marker"
4. QuickPick shows all configured marker types
5. "Remove Marker" only visible on files that have markers
6. "Open Configuration" command opens the JSON file for editing
7. Orphaned markers (referencing removed marker types) show fallback `⚠` badge

### Storage Format:

```json
{
  "markerTypes": [
    { "id": "done", "badge": "✓", "color": "gitDecoration.addedResourceForeground", "label": "Done" },
    { "id": "in-progress", "badge": "◐", "color": "gitDecoration.modifiedResourceForeground", "label": "In Progress" },
    { "id": "pending", "badge": "○", "color": "gitDecoration.deletedResourceForeground", "label": "Pending" },
    { "id": "important", "badge": "★", "color": "editorWarning.foreground", "label": "Important" },
    { "id": "review", "badge": "◉", "color": "editorInfo.foreground", "label": "Needs Review" },
    { "id": "question", "badge": "?", "color": "editorHint.foreground", "label": "Question" }
  ],
  "markers": {
    "src/file.ts": "done",
    "src/utils": "in-progress"
  }
}
```

### Verification:

- Right-click file → "File Markers: Add Marker..." → QuickPick appears with all marker types
- Select marker → badge appears
- Right-click marked file → "File Markers: Remove Marker" visible
- Command Palette → "File Markers: Open Configuration" → JSON file opens
- Edit markerTypes in JSON → reload → changes reflected in QuickPick
- Remove a markerType that's in use → reload → orphaned files show `⚠`

## What We're NOT Doing

- VSCode settings.json configuration (everything in markers file)
- Nested submenu (flat context menu instead)
- Static menu items per marker type (QuickPick instead)
- Migration from v1 (not releasing publicly)
- Real-time config changes (requires reload)

## Implementation Approach

1. Update storage format and add migration from v1 to v2
2. Create marker registry that reads from storage
3. Simplify package.json to flat context menu with 2 commands
4. Implement QuickPick-based "Add Marker" command
5. Add context-aware "Remove Marker" visibility
6. Add "Open Configuration" command
7. Update decoration provider with fallback support

---

## Phase 1: Update Types & Storage Format

### Overview

Define new types for the v2 storage format and update the storage service to handle marker type definitions.

### Changes Required:

#### 1. Update Types

**File**: `src/types.ts`
**Changes**: Add types for marker type configuration in storage

```typescript
import * as vscode from 'vscode';

/**
 * Marker type definition as stored in config file
 */
export interface MarkerTypeConfig {
  id: string;
  badge: string;
  color: string; // Theme color ID (e.g., "gitDecoration.addedResourceForeground")
  label: string;
}

/**
 * Runtime marker type with resolved color
 */
export interface MarkerType {
  id: string;
  badge: string;
  color: vscode.ThemeColor;
  label: string;
}

/**
 * Storage format - includes marker type definitions
 */
export interface MarkerStorageData {
  markerTypes: MarkerTypeConfig[];
  markers: Record<string, string>; // relativePath -> markerId
}

/**
 * Event fired when markers change
 */
export interface MarkerChangeEvent {
  uri: vscode.Uri;
  markerId: string | undefined;
}
```

#### 2. Create Default Marker Types Constant

**File**: `src/defaults.ts` (new file)

```typescript
import { MarkerTypeConfig } from './types';

/**
 * Default marker types used when creating new storage file
 */
export const DEFAULT_MARKER_TYPES: MarkerTypeConfig[] = [
  {
    id: 'done',
    badge: '✓',
    color: 'gitDecoration.addedResourceForeground',
    label: 'Done',
  },
  {
    id: 'in-progress',
    badge: '◐',
    color: 'gitDecoration.modifiedResourceForeground',
    label: 'In Progress',
  },
  {
    id: 'pending',
    badge: '○',
    color: 'gitDecoration.deletedResourceForeground',
    label: 'Pending',
  },
  {
    id: 'important',
    badge: '★',
    color: 'editorWarning.foreground',
    label: 'Important',
  },
  {
    id: 'review',
    badge: '◉',
    color: 'editorInfo.foreground',
    label: 'Needs Review',
  },
  {
    id: 'question',
    badge: '?',
    color: 'editorHint.foreground',
    label: 'Question',
  },
];
```

### Success Criteria:

#### Automated Verification:

- [x] Type checking passes: `pnpm run check-types` (will pass after Phase 2 updates storage.ts)
- [x] Linting passes: `pnpm run lint`

**Implementation Note**: After completing this phase and all automated verification passes, proceed to Phase 2.

---

## Phase 2: Update MarkerStorage

### Overview

Update MarkerStorage to read/write the new format, including marker type definitions.

### Changes Required:

#### 1. Rewrite MarkerStorage

**File**: `src/storage.ts`
**Changes**: Complete rewrite to handle v2 format with migration

```typescript
import * as vscode from 'vscode';
import * as path from 'path';
import { MarkerStorageData, MarkerChangeEvent, MarkerTypeConfig, MarkerType } from './types';
import { DEFAULT_MARKER_TYPES } from './defaults';

const STORAGE_FILENAME = 'file-markers.json';

/**
 * Fallback marker for unknown/orphaned marker IDs
 */
export const FALLBACK_MARKER: MarkerType = {
  id: '__unknown__',
  badge: '⚠',
  color: new vscode.ThemeColor('editorWarning.foreground'),
  label: 'Unknown Marker',
};

export class MarkerStorage implements vscode.Disposable {
  private markerTypes: Map<string, MarkerType> = new Map();
  private markers: Map<string, string> = new Map();
  private storageUri: vscode.Uri | undefined;
  private disposables: vscode.Disposable[] = [];
  private writeDebounceTimer: NodeJS.Timeout | undefined;

  private readonly _onDidChangeMarkers = new vscode.EventEmitter<MarkerChangeEvent>();
  readonly onDidChangeMarkers = this._onDidChangeMarkers.event;

  constructor() {
    this.disposables.push(
      vscode.workspace.onDidChangeWorkspaceFolders(() => this.initialize())
    );
  }

  async initialize(): Promise<void> {
    const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
    if (!workspaceFolder) {
      this.markerTypes.clear();
      this.markers.clear();
      this.storageUri = undefined;
      return;
    }

    this.storageUri = vscode.Uri.joinPath(
      workspaceFolder.uri,
      '.vscode',
      STORAGE_FILENAME
    );

    await this.load();
  }

  private async load(): Promise<void> {
    if (!this.storageUri) {
      return;
    }

    try {
      const content = await vscode.workspace.fs.readFile(this.storageUri);
      const data = JSON.parse(Buffer.from(content).toString('utf8'));

      this.loadMarkerTypes(data.markerTypes || DEFAULT_MARKER_TYPES);
      this.markers = new Map(Object.entries(data.markers || {}));
    } catch {
      // File doesn't exist or is invalid - use defaults
      this.loadMarkerTypes(DEFAULT_MARKER_TYPES);
      this.markers.clear();
    }
  }

  private loadMarkerTypes(configs: MarkerTypeConfig[]): void {
    this.markerTypes.clear();
    for (const config of configs) {
      if (this.isValidMarkerTypeConfig(config)) {
        this.markerTypes.set(config.id, {
          id: config.id,
          badge: config.badge.substring(0, 2),
          color: new vscode.ThemeColor(config.color),
          label: config.label,
        });
      }
    }
  }

  private isValidMarkerTypeConfig(config: unknown): config is MarkerTypeConfig {
    if (!config || typeof config !== 'object') {
      return false;
    }
    const c = config as Record<string, unknown>;
    return (
      typeof c.id === 'string' && c.id.length > 0 &&
      typeof c.badge === 'string' && c.badge.length > 0 &&
      typeof c.color === 'string' && c.color.length > 0 &&
      typeof c.label === 'string' && c.label.length > 0
    );
  }

  private async save(): Promise<void> {
    if (!this.storageUri) {
      return;
    }

    // Convert marker types back to config format
    const markerTypes: MarkerTypeConfig[] = Array.from(this.markerTypes.values()).map(m => ({
      id: m.id,
      badge: m.badge,
      color: m.color.id, // ThemeColor.id contains the color ID string
      label: m.label,
    }));

    const data: MarkerStorageData = {
      markerTypes,
      markers: Object.fromEntries(this.markers),
    };

    const content = Buffer.from(JSON.stringify(data, null, 2), 'utf8');

    // Ensure .vscode directory exists
    const vscodeDir = vscode.Uri.joinPath(this.storageUri, '..');
    try {
      await vscode.workspace.fs.createDirectory(vscodeDir);
    } catch {
      // Directory may already exist
    }

    await vscode.workspace.fs.writeFile(this.storageUri, content);
  }

  private scheduleSave(): void {
    if (this.writeDebounceTimer) {
      clearTimeout(this.writeDebounceTimer);
    }
    this.writeDebounceTimer = setTimeout(() => {
      this.save().catch(err => {
        console.error('Failed to save markers:', err);
      });
    }, 100);
  }

  /**
   * Get the storage file URI (for "Open Configuration" command)
   */
  getStorageUri(): vscode.Uri | undefined {
    return this.storageUri;
  }

  /**
   * Get all configured marker types
   */
  getAllMarkerTypes(): MarkerType[] {
    return Array.from(this.markerTypes.values());
  }

  /**
   * Get a marker type by ID, returns fallback for unknown IDs
   */
  getMarkerType(id: string): MarkerType {
    return this.markerTypes.get(id) ?? FALLBACK_MARKER;
  }

  /**
   * Check if a marker type ID is known
   */
  isKnownMarkerType(id: string): boolean {
    return this.markerTypes.has(id);
  }

  /**
   * Get the marker ID for a given URI
   */
  getMarker(uri: vscode.Uri): string | undefined {
    const relativePath = this.getRelativePath(uri);
    if (!relativePath) {
      return undefined;
    }
    return this.markers.get(relativePath);
  }

  /**
   * Set or update a marker for a given URI
   */
  setMarker(uri: vscode.Uri, markerId: string): void {
    const relativePath = this.getRelativePath(uri);
    if (!relativePath) {
      return;
    }

    this.markers.set(relativePath, markerId);
    this.scheduleSave();
    this._onDidChangeMarkers.fire({ uri, markerId });
  }

  /**
   * Remove a marker from a given URI
   */
  removeMarker(uri: vscode.Uri): void {
    const relativePath = this.getRelativePath(uri);
    if (!relativePath) {
      return;
    }

    if (this.markers.delete(relativePath)) {
      this.scheduleSave();
      this._onDidChangeMarkers.fire({ uri, markerId: undefined });
    }
  }

  /**
   * Check if a URI has a marker
   */
  hasMarker(uri: vscode.Uri): boolean {
    return this.getMarker(uri) !== undefined;
  }

  /**
   * Get all marked URIs
   */
  getAllMarkedUris(): vscode.Uri[] {
    const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
    if (!workspaceFolder) {
      return [];
    }

    return Array.from(this.markers.keys()).map(relativePath =>
      vscode.Uri.joinPath(workspaceFolder.uri, relativePath)
    );
  }

  private getRelativePath(uri: vscode.Uri): string | undefined {
    const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
    if (!workspaceFolder) {
      return undefined;
    }

    const workspacePath = workspaceFolder.uri.fsPath;
    const filePath = uri.fsPath;

    if (!filePath.startsWith(workspacePath)) {
      return undefined;
    }

    return path.relative(workspacePath, filePath).split(path.sep).join('/');
  }

  dispose(): void {
    if (this.writeDebounceTimer) {
      clearTimeout(this.writeDebounceTimer);
    }
    this._onDidChangeMarkers.dispose();
    this.disposables.forEach(d => d.dispose());
  }
}
```

### Success Criteria:

#### Automated Verification:

- [x] Type checking passes: `pnpm run check-types` (will pass after Phase 7 removes markers.ts)
- [x] Linting passes: `pnpm run lint`

**Implementation Note**: After completing this phase and all automated verification passes, proceed to Phase 3.

---

## Phase 3: Update Decoration Provider

### Overview

Update the decoration provider to use the new storage API with fallback support.

### Changes Required:

#### 1. Simplify MarkerDecorationProvider

**File**: `src/decorationProvider.ts`
**Changes**: Use storage for both marker types and assignments

```typescript
import * as vscode from 'vscode';
import { MarkerStorage, FALLBACK_MARKER } from './storage';

export class MarkerDecorationProvider
  implements vscode.FileDecorationProvider, vscode.Disposable
{
  private disposables: vscode.Disposable[] = [];

  private readonly _onDidChangeFileDecorations =
    new vscode.EventEmitter<vscode.Uri | vscode.Uri[] | undefined>();
  readonly onDidChangeFileDecorations = this._onDidChangeFileDecorations.event;

  constructor(private readonly storage: MarkerStorage) {
    this.disposables.push(
      storage.onDidChangeMarkers(event => {
        this._onDidChangeFileDecorations.fire(event.uri);
      })
    );
  }

  provideFileDecoration(
    uri: vscode.Uri,
    _token: vscode.CancellationToken
  ): vscode.ProviderResult<vscode.FileDecoration> {
    const markerId = this.storage.getMarker(uri);
    if (!markerId) {
      return undefined;
    }

    const marker = this.storage.getMarkerType(markerId);

    let tooltip = `File Marker: ${marker.label}`;
    if (marker.id === FALLBACK_MARKER.id) {
      tooltip = `Unknown marker type: "${markerId}"`;
    }

    return {
      badge: marker.badge,
      color: marker.color,
      tooltip,
      propagate: false,
    };
  }

  refresh(): void {
    this._onDidChangeFileDecorations.fire(undefined);
  }

  dispose(): void {
    this._onDidChangeFileDecorations.dispose();
    this.disposables.forEach(d => d.dispose());
  }
}
```

### Success Criteria:

#### Automated Verification:

- [x] Type checking passes: `pnpm run check-types` (will pass after Phase 7 removes markers.ts)
- [x] Linting passes: `pnpm run lint`

**Implementation Note**: After completing this phase and all automated verification passes, proceed to Phase 4.

---

## Phase 4: Update Commands with QuickPick

### Overview

Replace individual marker commands with a single QuickPick-based "Add Marker" command, plus "Remove Marker" and "Open Configuration" commands.

### Changes Required:

#### 1. Rewrite Commands Module

**File**: `src/commands.ts`
**Changes**: Complete rewrite with new command structure

```typescript
import * as vscode from 'vscode';
import { MarkerStorage } from './storage';

export function registerCommands(
  context: vscode.ExtensionContext,
  storage: MarkerStorage
): void {
  // Add Marker command with QuickPick
  context.subscriptions.push(
    vscode.commands.registerCommand(
      'file-markers.addMarker',
      async (uri: vscode.Uri) => {
        if (!uri) {
          return;
        }

        const markerTypes = storage.getAllMarkerTypes();
        if (markerTypes.length === 0) {
          vscode.window.showWarningMessage(
            'No marker types configured. Open configuration to add marker types.'
          );
          return;
        }

        const currentMarkerId = storage.getMarker(uri);

        const items = markerTypes.map(m => ({
          label: `${m.badge} ${m.label}`,
          description: m.id === currentMarkerId ? '(current)' : undefined,
          markerId: m.id,
        }));

        const selected = await vscode.window.showQuickPick(items, {
          placeHolder: 'Select a marker to apply',
        });

        if (selected) {
          storage.setMarker(uri, selected.markerId);
        }
      }
    )
  );

  // Remove Marker command
  context.subscriptions.push(
    vscode.commands.registerCommand(
      'file-markers.removeMarker',
      (uri: vscode.Uri) => {
        if (uri) {
          storage.removeMarker(uri);
        }
      }
    )
  );

  // Open Configuration command
  context.subscriptions.push(
    vscode.commands.registerCommand(
      'file-markers.openConfig',
      async () => {
        const storageUri = storage.getStorageUri();
        if (!storageUri) {
          vscode.window.showWarningMessage(
            'No workspace folder open. Open a folder first.'
          );
          return;
        }

        // Ensure file exists before opening
        try {
          await vscode.workspace.fs.stat(storageUri);
        } catch {
          // File doesn't exist, create it with defaults
          const { DEFAULT_MARKER_TYPES } = await import('./defaults');
          const initialData = {
            markerTypes: DEFAULT_MARKER_TYPES,
            markers: {},
          };
          const content = Buffer.from(JSON.stringify(initialData, null, 2), 'utf8');

          // Ensure .vscode directory exists
          const vscodeDir = vscode.Uri.joinPath(storageUri, '..');
          try {
            await vscode.workspace.fs.createDirectory(vscodeDir);
          } catch {
            // Directory may already exist
          }

          await vscode.workspace.fs.writeFile(storageUri, content);
        }

        const doc = await vscode.workspace.openTextDocument(storageUri);
        await vscode.window.showTextDocument(doc);
      }
    )
  );
}
```

### Success Criteria:

#### Automated Verification:

- [x] Type checking passes: `pnpm run check-types` (will pass after Phase 7 removes markers.ts)
- [x] Linting passes: `pnpm run lint`

**Implementation Note**: After completing this phase and all automated verification passes, proceed to Phase 5.

---

## Phase 5: Update package.json

### Overview

Simplify package.json to flat context menu with new commands and context-aware visibility.

### Changes Required:

#### 1. Update package.json

**File**: `package.json`
**Changes**: Replace entire `contributes` section

```json
{
  "contributes": {
    "commands": [
      {
        "command": "file-markers.addMarker",
        "title": "File Markers: Add Marker..."
      },
      {
        "command": "file-markers.removeMarker",
        "title": "File Markers: Remove Marker"
      },
      {
        "command": "file-markers.openConfig",
        "title": "File Markers: Open Configuration"
      }
    ],
    "menus": {
      "explorer/context": [
        {
          "command": "file-markers.addMarker",
          "group": "2_workspace@1"
        },
        {
          "command": "file-markers.removeMarker",
          "group": "2_workspace@2",
          "when": "fileMarkers.hasMarker"
        }
      ],
      "commandPalette": [
        {
          "command": "file-markers.addMarker",
          "when": "false"
        },
        {
          "command": "file-markers.removeMarker",
          "when": "false"
        },
        {
          "command": "file-markers.openConfig"
        }
      ]
    }
  }
}
```

Note: `file-markers.addMarker` and `file-markers.removeMarker` are hidden from command palette since they require a URI context.

### Success Criteria:

#### Automated Verification:

- [x] Extension compiles: `pnpm run compile` (will pass after Phase 7 removes markers.ts)

**Implementation Note**: After completing this phase and all automated verification passes, proceed to Phase 6.

---

## Phase 6: Context-Aware Menu Visibility

### Overview

Set the `fileMarkers.hasMarker` context when user right-clicks a file, so "Remove Marker" only shows on marked files.

### Changes Required:

#### 1. Add Context Key Updates

**File**: `src/extension.ts`
**Changes**: Update context when explorer selection changes

```typescript
import * as vscode from 'vscode';
import { MarkerStorage } from './storage';
import { MarkerDecorationProvider } from './decorationProvider';
import { registerCommands } from './commands';

let storage: MarkerStorage | undefined;
let decorationProvider: MarkerDecorationProvider | undefined;

export async function activate(
  context: vscode.ExtensionContext
): Promise<void> {
  console.log('File Markers extension is now active');

  // Initialize storage
  storage = new MarkerStorage();
  await storage.initialize();
  context.subscriptions.push(storage);

  // Initialize decoration provider
  decorationProvider = new MarkerDecorationProvider(storage);
  context.subscriptions.push(decorationProvider);

  // Register decoration provider with VSCode
  context.subscriptions.push(
    vscode.window.registerFileDecorationProvider(decorationProvider)
  );

  // Register commands
  registerCommands(context, storage);

  // Update context key when markers change
  context.subscriptions.push(
    storage.onDidChangeMarkers(() => {
      updateContextKey(storage);
    })
  );

  // Update context key on selection change (for context menu visibility)
  context.subscriptions.push(
    vscode.window.onDidChangeActiveTextEditor(editor => {
      if (editor) {
        updateContextKey(storage, editor.document.uri);
      }
    })
  );

  // Refresh decorations after initialization
  decorationProvider.refresh();
}

function updateContextKey(
  storage: MarkerStorage | undefined,
  uri?: vscode.Uri
): void {
  if (!storage) {
    vscode.commands.executeCommand('setContext', 'fileMarkers.hasMarker', false);
    return;
  }

  // If URI provided, check that specific file
  if (uri) {
    const hasMarker = storage.hasMarker(uri);
    vscode.commands.executeCommand('setContext', 'fileMarkers.hasMarker', hasMarker);
  }
}

export function deactivate(): void {
  storage = undefined;
  decorationProvider = undefined;
}
```

**Important Note**: The `when` clause for explorer context menu is evaluated based on the right-clicked item, not the active editor. VSCode automatically provides the `resourceUri` context variable for explorer items. However, we need a different approach - we'll use a command wrapper.

#### 2. Alternative: Use Command Enablement

Actually, a cleaner approach is to always show "Remove Marker" but have it do nothing (or show a message) if the file has no marker. This avoids complex context key management.

**Updated approach in `src/commands.ts`:**

```typescript
  // Remove Marker command
  context.subscriptions.push(
    vscode.commands.registerCommand(
      'file-markers.removeMarker',
      (uri: vscode.Uri) => {
        if (!uri) {
          return;
        }

        if (!storage.hasMarker(uri)) {
          // Silently do nothing if no marker
          return;
        }

        storage.removeMarker(uri);
      }
    )
  );
```

And simplify package.json to always show both items:

```json
{
  "menus": {
    "explorer/context": [
      {
        "command": "file-markers.addMarker",
        "group": "2_workspace@1"
      },
      {
        "command": "file-markers.removeMarker",
        "group": "2_workspace@2"
      }
    ]
  }
}
```

This is simpler and the UX is still good - clicking "Remove Marker" on an unmarked file simply does nothing.

### Success Criteria:

#### Automated Verification:

- [x] Type checking passes: `pnpm run check-types` (will pass after Phase 7 removes markers.ts)
- [x] Linting passes: `pnpm run lint`
- [x] Extension compiles: `pnpm run compile` (will pass after Phase 7 removes markers.ts)

**Implementation Note**: After completing this phase and all automated verification passes, proceed to Phase 7.

---

## Phase 7: Cleanup & Version Bump

### Overview

Remove old marker files, update version, and clean up.

### Changes Required:

#### 1. Delete Old Markers Module

**File**: `src/markers.ts`
**Action**: Delete this file (functionality moved to storage.ts and defaults.ts)

#### 2. Update package.json Version

**File**: `package.json`
**Changes**: Bump version

```json
{
  "version": "0.2.0"
}
```

#### 3. Update Extension Entry Point (Final)

**File**: `src/extension.ts`
**Changes**: Final clean version

```typescript
import * as vscode from 'vscode';
import { MarkerStorage } from './storage';
import { MarkerDecorationProvider } from './decorationProvider';
import { registerCommands } from './commands';

let storage: MarkerStorage | undefined;
let decorationProvider: MarkerDecorationProvider | undefined;

export async function activate(
  context: vscode.ExtensionContext
): Promise<void> {
  console.log('File Markers extension is now active');

  // Initialize storage (includes marker type definitions)
  storage = new MarkerStorage();
  await storage.initialize();
  context.subscriptions.push(storage);

  // Initialize decoration provider
  decorationProvider = new MarkerDecorationProvider(storage);
  context.subscriptions.push(decorationProvider);

  // Register decoration provider with VSCode
  context.subscriptions.push(
    vscode.window.registerFileDecorationProvider(decorationProvider)
  );

  // Register commands
  registerCommands(context, storage);

  // Refresh decorations after initialization
  decorationProvider.refresh();
}

export function deactivate(): void {
  storage = undefined;
  decorationProvider = undefined;
}
```

### Success Criteria:

#### Automated Verification:

- [x] Type checking passes: `pnpm run check-types`
- [x] Linting passes: `pnpm run lint`
- [x] Extension compiles: `pnpm run compile`

#### Manual Verification:

- [x] Press F5 to launch Extension Development Host
- [x] Right-click file → "File Markers: Add Marker..." appears
- [x] Click → QuickPick shows 6 default markers
- [x] Select marker → badge appears
- [x] Right-click same file → "File Markers: Remove Marker" appears
- [x] Click Remove → badge disappears
- [x] Command Palette → "File Markers: Open Configuration"
- [x] JSON file opens with markerTypes and markers
- [x] Edit markerTypes (add custom marker) → reload extension → new marker in QuickPick
- [x] Apply custom marker → badge shows
- [x] Remove custom marker type from JSON → reload → orphaned files show ⚠ (badge only, no color)

**Implementation Note**: After completing this phase and all verification passes, v0.2.0 is complete.

---

## Testing Strategy

### Manual Testing Steps:

1. **Fresh workspace**
   - Open new folder
   - Right-click file → Add Marker → select marker → badge appears
   - Check `.vscode/file-markers.json` exists with correct format

2. **Custom marker types**
   - Open Configuration
   - Add new marker type: `{ "id": "custom", "badge": "C", "color": "foreground", "label": "Custom" }`
   - Reload extension
   - Add Marker → "C Custom" appears in QuickPick
   - Apply → badge shows

3. **Orphaned markers**
   - Apply custom marker to file
   - Remove custom marker type from config
   - Reload
   - File shows ⚠ with tooltip "Unknown marker type: custom"

4. **Remove marker**
   - Mark file
   - Right-click → Remove Marker
   - Badge disappears

5. **Edge cases**
   - Remove Marker on unmarked file (should do nothing)
   - Invalid marker type in config (should be skipped)
   - Empty markerTypes array (should show warning)

## File Structure After Implementation

```
src/
├── extension.ts          # Entry point
├── types.ts              # TypeScript interfaces
├── defaults.ts           # Default marker type definitions
├── storage.ts            # MarkerStorage with marker types + assignments
├── decorationProvider.ts # FileDecorationProvider
├── commands.ts           # Command registrations
└── test/
    └── extension.test.ts # Tests
```

## References

- MVP Plan: `thoughts/shared/plans/2026-01-31-mvp-v0.1.0-file-markers.md`
- PRD: `PRD.md`
- VSCode Context Keys: https://code.visualstudio.com/api/references/when-clause-contexts
- VSCode QuickPick API: https://code.visualstudio.com/api/references/vscode-api#window.showQuickPick
